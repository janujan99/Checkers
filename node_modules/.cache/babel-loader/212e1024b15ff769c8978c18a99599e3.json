{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getNonCaptureMoves = exports.isValidCoordinate = exports.Colour = exports.TurnType = exports.Turn = void 0;\nvar Turn;\n\n(function (Turn) {\n  Turn[Turn[\"RedTurn\"] = 1] = \"RedTurn\";\n  Turn[Turn[\"BlackTurn\"] = 2] = \"BlackTurn\";\n})(Turn = exports.Turn || (exports.Turn = {}));\n\nvar TurnType;\n\n(function (TurnType) {\n  TurnType[TurnType[\"Continue\"] = 1] = \"Continue\";\n  TurnType[TurnType[\"Next\"] = 2] = \"Next\";\n})(TurnType = exports.TurnType || (exports.TurnType = {}));\n\nvar Colour;\n\n(function (Colour) {\n  Colour[Colour[\"Red\"] = 1] = \"Red\";\n  Colour[Colour[\"Black\"] = 2] = \"Black\";\n})(Colour = exports.Colour || (exports.Colour = {}));\n\nfunction isValidCoordinate(position) {\n  return position.x < 8 && position.x >= 0 && position.y < 8 && position.y >= 0;\n}\n\nexports.isValidCoordinate = isValidCoordinate;\n\nfunction getNonCaptureMoves(piece, board) {\n  var moves;\n  var directionFactor = piece.colour === Colour.Red ? -1 : 1; //get possible move locations\n\n  if (piece.hasPromoted) moves = [{\n    x: piece.position.x + 1,\n    y: piece.position.y + 1\n  }, {\n    x: piece.position.x - 1,\n    y: piece.position.y + 1\n  }, {\n    x: piece.position.x + 1,\n    y: piece.position.y - 1\n  }, {\n    x: piece.position.x - 1,\n    y: piece.position.y - 1\n  }];else moves = [{\n    x: piece.position.x + 1,\n    y: piece.position.y + directionFactor\n  }, {\n    x: piece.position.x - 1,\n    y: piece.position.y + directionFactor\n  }];\n  var filteredMoves = [];\n\n  for (var i = 0; i < moves.length; i++) {\n    if (isValidCoordinate(moves[i]) && board.grid[moves[i].y][moves[i].x] === null) filteredMoves.push(moves[i]);\n  }\n\n  return filteredMoves;\n}\n\nexports.getNonCaptureMoves = getNonCaptureMoves;\n\nfunction getCaptureMoves(piece, board) {\n  var moves;\n  var directionFactor = piece.colour === Colour.Red ? -1 : 1;\n  if (piece.hasPromoted) moves = [{\n    x: piece.position.x + 2,\n    y: piece.position.y + 2\n  }, {\n    x: piece.position.x - 2,\n    y: piece.position.y + 2\n  }, {\n    x: piece.position.x + 2,\n    y: piece.position.y - 2\n  }, {\n    x: piece.position.x - 2,\n    y: piece.position.y - 2\n  }];else moves = [{\n    x: piece.position.x + 2,\n    y: piece.position.y + 2 * directionFactor\n  }, {\n    x: piece.position.x - 2,\n    y: piece.position.y + 2 * directionFactor\n  }];\n  var filteredMoves = [];\n\n  for (var i = 0; i < moves.length; i++) {\n    if (isValidCoordinate(moves[i]) && board.grid[moves[i].y][moves[i].x] === null && board.grid[(moves[i].y + piece.position.y) / 2][(moves[i].x + piece.position.x) / 2] !== null && board.grid[(moves[i].y + piece.position.y) / 2][(moves[i].x + piece.position.x) / 2].colour !== piece.colour) filteredMoves.push(moves[i]);\n  }\n\n  return filteredMoves;\n}\n\nfunction makeMove(initial, final, prevState) {\n  var tempGrid = []; //create deep copy of the board\n\n  for (var i = 0; i < 8; i++) {\n    var temp = [];\n\n    for (var j = 0; j < 8; j++) {\n      if (prevState.board.grid[i][j] === null) temp.push(null);else {\n        var piece = prevState.board.grid[i][j];\n        var checker = {\n          colour: piece.colour,\n          position: {\n            x: piece.position.x,\n            y: piece.position.y\n          },\n          hasPromoted: piece.hasPromoted\n        };\n        temp.push(checker);\n      }\n    }\n\n    tempGrid.push(temp);\n  }\n\n  var movingChecker = tempGrid[initial.y][initial.x];\n  if (movingChecker === null) return prevState;\n  var newChecker = {\n    colour: movingChecker.colour,\n    position: final,\n    hasPromoted: movingChecker.hasPromoted\n  }; //promote if back rank has been reached\n\n  if (movingChecker.colour === Colour.Red && final.y === 0 || movingChecker.colour === Colour.Black && final.y === 7) newChecker.hasPromoted = true;\n  tempGrid[initial.y][initial.x] = null;\n  tempGrid[final.y][final.x] = newChecker;\n  var captureMade = false;\n\n  if (Math.abs(initial.x - final.x) == 2) {\n    captureMade = true;\n    tempGrid[(initial.y + final.y) / 2][(initial.x + final.x) / 2] = null;\n  }\n\n  var nextTurnType = captureMade && getCaptureMoves(tempGrid[final.y][final.x], {\n    grid: tempGrid\n  }).length > 0 ? TurnType.Continue : TurnType.Next;\n  var otherTurn = prevState.turn === Turn.RedTurn ? Turn.BlackTurn : Turn.RedTurn;\n  var nextTurn = nextTurnType === TurnType.Continue ? prevState.turn : otherTurn;\n  return {\n    board: {\n      grid: tempGrid\n    },\n    turn: nextTurn,\n    turnType: nextTurnType,\n    gameOver: prevState.gameOver,\n    currentPieceLocation: final\n  };\n}\n\nfunction printBoard(board) {\n  var _a;\n\n  for (var i = 0; i < 8; i++) {\n    var st = \"\";\n\n    for (var j = 0; j < 8; j++) {\n      var ch = void 0;\n      if (board.grid[i][j] == null) st += \" -\";else {\n        var ch_1 = board.grid[i][j].colour === Colour.Red ? \"r\" : \"b\";\n        if ((_a = board.grid[i][j]) === null || _a === void 0 ? void 0 : _a.hasPromoted) ch_1 = ch_1.toUpperCase();\n        st = st + \" \" + ch_1;\n      }\n    }\n\n    console.log(st);\n  }\n}\n\nfunction newState() {\n  var board = {\n    grid: [[null, {\n      colour: Colour.Black,\n      position: {\n        x: 1,\n        y: 0\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 3,\n        y: 0\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 5,\n        y: 0\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 7,\n        y: 0\n      },\n      hasPromoted: false\n    }], [{\n      colour: Colour.Black,\n      position: {\n        x: 0,\n        y: 1\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 2,\n        y: 1\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 4,\n        y: 1\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 6,\n        y: 1\n      },\n      hasPromoted: false\n    }, null], [null, {\n      colour: Colour.Black,\n      position: {\n        x: 1,\n        y: 2\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 3,\n        y: 2\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 5,\n        y: 2\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 7,\n        y: 2\n      },\n      hasPromoted: false\n    }], Array(8).fill(null), Array(8).fill(null), [{\n      colour: Colour.Red,\n      position: {\n        x: 0,\n        y: 5\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 2,\n        y: 5\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 4,\n        y: 5\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 6,\n        y: 5\n      },\n      hasPromoted: false\n    }, null], [null, {\n      colour: Colour.Red,\n      position: {\n        x: 1,\n        y: 6\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 3,\n        y: 6\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 5,\n        y: 6\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 7,\n        y: 6\n      },\n      hasPromoted: false\n    }], [{\n      colour: Colour.Red,\n      position: {\n        x: 0,\n        y: 7\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 2,\n        y: 7\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 4,\n        y: 7\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 6,\n        y: 7\n      },\n      hasPromoted: false\n    }, null]]\n  };\n  return {\n    board: board,\n    turn: Turn.RedTurn,\n    turnType: TurnType.Next,\n    gameOver: false,\n    currentPieceLocation: {\n      x: -1,\n      y: -1\n    }\n  };\n}\n\nfunction gameOver(gameState) {\n  var colour = gameState.turn === Turn.RedTurn ? Colour.Black : Colour.Red; // check if the other player has any moves left to make or has any pieces left\n\n  for (var i = 0; i < 8; i++) {\n    for (var j = 0; j < 8; j++) {\n      var square = gameState.board.grid[i][j];\n      if (square !== null && square.colour === colour && getCaptureMoves(square, gameState.board).concat(getNonCaptureMoves(square, gameState.board)).length > 0) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isValidPiece(pieceX, pieceY, gameState) {\n  return isValidCoordinate({\n    x: pieceX,\n    y: pieceY\n  }) && gameState.board.grid[pieceY][pieceX] !== null && (gameState.board.grid[pieceY][pieceX].colour === Colour.Red && gameState.turn === Turn.RedTurn || gameState.board.grid[pieceY][pieceX].colour === Colour.Black && gameState.turn === Turn.BlackTurn) && getCaptureMoves(gameState.board.grid[pieceY][pieceX], gameState.board).concat(getNonCaptureMoves(gameState.board.grid[pieceY][pieceX], gameState.board)).length > 0;\n}\n\nfunction main() {\n  var state = newState();\n\n  var prompt_sync = require(\"prompt-sync\")();\n\n  while (!gameOver(state)) {\n    printBoard(state.board);\n    console.log(state.turn === Turn.RedTurn ? \"Red's turn\" : \"Black's Turn\"); // Next turn\n\n    if (state.turnType === TurnType.Next) {\n      var validPiece = false;\n      var inputX = -1;\n      var inputY = -1;\n\n      while (!validPiece) {\n        inputX = parseInt(prompt_sync(\"Enter column of piece: \"));\n        inputY = parseInt(prompt_sync(\"Enter row of piece: \"));\n        if (isValidPiece(inputX, inputY, state)) validPiece = true;else console.log(\"Invalid piece location. Try again\");\n      }\n\n      var captureMoves = getCaptureMoves(state.board.grid[inputY][inputX], state.board);\n      var nonCaptureMoves = getNonCaptureMoves(state.board.grid[inputY][inputX], state.board);\n      var allMoves = captureMoves.concat(nonCaptureMoves);\n      var validMove = false;\n      var moveIndex = -1;\n      console.log(allMoves);\n\n      while (!validMove) {\n        moveIndex = parseInt(prompt_sync(\"Enter index in moves array: \"));\n        if (moveIndex >= 0 && moveIndex < allMoves.length) validMove = true;else console.log(\"Invalid move index. Try again.\");\n      } // assume state is immutable and reassign state as needed\n\n\n      var newState_1 = makeMove({\n        x: inputX,\n        y: inputY\n      }, {\n        x: allMoves[moveIndex].x,\n        y: allMoves[moveIndex].y\n      }, state);\n      state = newState_1;\n    } // Next turn\n    else {\n      var captureMoves = getCaptureMoves(state.board.grid[state.currentPieceLocation.y][state.currentPieceLocation.x], state.board);\n      var validCapture = false;\n      var captureIndex = -1;\n      console.log(captureMoves);\n\n      while (!validCapture) {\n        captureIndex = parseInt(prompt_sync(\"Enter index in capture moves array: \"));\n        if (captureIndex >= 0 && captureIndex < captureMoves.length) validCapture = true;else console.log(\"Invalid move index. Try again.\");\n      }\n\n      var newState_2 = makeMove({\n        x: state.currentPieceLocation.x,\n        y: state.currentPieceLocation.y\n      }, {\n        x: captureMoves[captureIndex].x,\n        y: captureMoves[captureIndex].y\n      }, state);\n      state = newState_2;\n    }\n  }\n\n  if (state.turn === Turn.RedTurn) console.log(\"Black wins! \");else console.log(\"Red wins! \");\n}\n\nmain();","map":{"version":3,"sources":["/Users/janujansritharan/Projects/Checkers-React/src/checkersState.js"],"names":["exports","__esModule","getNonCaptureMoves","isValidCoordinate","Colour","TurnType","Turn","position","x","y","piece","board","moves","directionFactor","colour","Red","hasPromoted","filteredMoves","i","length","grid","push","getCaptureMoves","makeMove","initial","final","prevState","tempGrid","temp","j","checker","movingChecker","newChecker","Black","captureMade","Math","abs","nextTurnType","Continue","Next","otherTurn","turn","RedTurn","BlackTurn","nextTurn","turnType","gameOver","currentPieceLocation","printBoard","_a","st","ch","ch_1","toUpperCase","console","log","newState","Array","fill","gameState","square","concat","isValidPiece","pieceX","pieceY","main","state","prompt_sync","require","validPiece","inputX","inputY","parseInt","captureMoves","nonCaptureMoves","allMoves","validMove","moveIndex","newState_1","validCapture","captureIndex","newState_2"],"mappings":"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","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nexports.getNonCaptureMoves = exports.isValidCoordinate = exports.Colour = exports.TurnType = exports.Turn = void 0;\nvar Turn;\n(function (Turn) {\n    Turn[Turn[\"RedTurn\"] = 1] = \"RedTurn\";\n    Turn[Turn[\"BlackTurn\"] = 2] = \"BlackTurn\";\n})(Turn = exports.Turn || (exports.Turn = {}));\nvar TurnType;\n(function (TurnType) {\n    TurnType[TurnType[\"Continue\"] = 1] = \"Continue\";\n    TurnType[TurnType[\"Next\"] = 2] = \"Next\";\n})(TurnType = exports.TurnType || (exports.TurnType = {}));\nvar Colour;\n(function (Colour) {\n    Colour[Colour[\"Red\"] = 1] = \"Red\";\n    Colour[Colour[\"Black\"] = 2] = \"Black\";\n})(Colour = exports.Colour || (exports.Colour = {}));\nfunction isValidCoordinate(position) {\n    return position.x < 8 && position.x >= 0 && position.y < 8 && position.y >= 0;\n}\nexports.isValidCoordinate = isValidCoordinate;\nfunction getNonCaptureMoves(piece, board) {\n    var moves;\n    var directionFactor = piece.colour === Colour.Red ? -1 : 1;\n    //get possible move locations\n    if (piece.hasPromoted)\n        moves = [\n            { x: piece.position.x + 1, y: piece.position.y + 1 },\n            { x: piece.position.x - 1, y: piece.position.y + 1 },\n            { x: piece.position.x + 1, y: piece.position.y - 1 },\n            { x: piece.position.x - 1, y: piece.position.y - 1 },\n        ];\n    else\n        moves = [\n            { x: piece.position.x + 1, y: piece.position.y + directionFactor },\n            { x: piece.position.x - 1, y: piece.position.y + directionFactor },\n        ];\n    var filteredMoves = [];\n    for (var i = 0; i < moves.length; i++) {\n        if (isValidCoordinate(moves[i]) &&\n            board.grid[moves[i].y][moves[i].x] === null)\n            filteredMoves.push(moves[i]);\n    }\n    return filteredMoves;\n}\nexports.getNonCaptureMoves = getNonCaptureMoves;\nfunction getCaptureMoves(piece, board) {\n    var moves;\n    var directionFactor = piece.colour === Colour.Red ? -1 : 1;\n    if (piece.hasPromoted)\n        moves = [\n            { x: piece.position.x + 2, y: piece.position.y + 2 },\n            { x: piece.position.x - 2, y: piece.position.y + 2 },\n            { x: piece.position.x + 2, y: piece.position.y - 2 },\n            { x: piece.position.x - 2, y: piece.position.y - 2 },\n        ];\n    else\n        moves = [\n            { x: piece.position.x + 2, y: piece.position.y + 2 * directionFactor },\n            { x: piece.position.x - 2, y: piece.position.y + 2 * directionFactor },\n        ];\n    var filteredMoves = [];\n    for (var i = 0; i < moves.length; i++) {\n        if (isValidCoordinate(moves[i]) &&\n            board.grid[moves[i].y][moves[i].x] === null &&\n            board.grid[(moves[i].y + piece.position.y) / 2][(moves[i].x + piece.position.x) / 2] !== null &&\n            board.grid[(moves[i].y + piece.position.y) / 2][(moves[i].x + piece.position.x) / 2].colour !== piece.colour)\n            filteredMoves.push(moves[i]);\n    }\n    return filteredMoves;\n}\nfunction makeMove(initial, final, prevState) {\n    var tempGrid = [];\n    //create deep copy of the board\n    for (var i = 0; i < 8; i++) {\n        var temp = [];\n        for (var j = 0; j < 8; j++) {\n            if (prevState.board.grid[i][j] === null)\n                temp.push(null);\n            else {\n                var piece = prevState.board.grid[i][j];\n                var checker = {\n                    colour: piece.colour,\n                    position: { x: piece.position.x, y: piece.position.y },\n                    hasPromoted: piece.hasPromoted\n                };\n                temp.push(checker);\n            }\n        }\n        tempGrid.push(temp);\n    }\n    var movingChecker = tempGrid[initial.y][initial.x];\n    if (movingChecker === null)\n        return prevState;\n    var newChecker = {\n        colour: movingChecker.colour,\n        position: final,\n        hasPromoted: movingChecker.hasPromoted\n    };\n    //promote if back rank has been reached\n    if ((movingChecker.colour === Colour.Red && final.y === 0) ||\n        (movingChecker.colour === Colour.Black && final.y === 7))\n        newChecker.hasPromoted = true;\n    tempGrid[initial.y][initial.x] = null;\n    tempGrid[final.y][final.x] = newChecker;\n    var captureMade = false;\n    if (Math.abs(initial.x - final.x) == 2) {\n        captureMade = true;\n        tempGrid[(initial.y + final.y) / 2][(initial.x + final.x) / 2] = null;\n    }\n    var nextTurnType = captureMade &&\n        getCaptureMoves(tempGrid[final.y][final.x], { grid: tempGrid }).length > 0\n        ? TurnType.Continue\n        : TurnType.Next;\n    var otherTurn = prevState.turn === Turn.RedTurn ? Turn.BlackTurn : Turn.RedTurn;\n    var nextTurn = nextTurnType === TurnType.Continue ? prevState.turn : otherTurn;\n    return {\n        board: { grid: tempGrid },\n        turn: nextTurn,\n        turnType: nextTurnType,\n        gameOver: prevState.gameOver,\n        currentPieceLocation: final\n    };\n}\nfunction printBoard(board) {\n    var _a;\n    for (var i = 0; i < 8; i++) {\n        var st = \"\";\n        for (var j = 0; j < 8; j++) {\n            var ch = void 0;\n            if (board.grid[i][j] == null)\n                st += \" -\";\n            else {\n                var ch_1 = board.grid[i][j].colour === Colour.Red ? \"r\" : \"b\";\n                if ((_a = board.grid[i][j]) === null || _a === void 0 ? void 0 : _a.hasPromoted)\n                    ch_1 = ch_1.toUpperCase();\n                st = st + \" \" + ch_1;\n            }\n        }\n        console.log(st);\n    }\n}\nfunction newState() {\n    var board = {\n        grid: [\n            [\n                null,\n                { colour: Colour.Black, position: { x: 1, y: 0 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 3, y: 0 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 5, y: 0 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 7, y: 0 }, hasPromoted: false },\n            ],\n            [\n                { colour: Colour.Black, position: { x: 0, y: 1 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 2, y: 1 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 4, y: 1 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 6, y: 1 }, hasPromoted: false },\n                null,\n            ],\n            [\n                null,\n                { colour: Colour.Black, position: { x: 1, y: 2 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 3, y: 2 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 5, y: 2 }, hasPromoted: false },\n                null,\n                { colour: Colour.Black, position: { x: 7, y: 2 }, hasPromoted: false },\n            ],\n            Array(8).fill(null),\n            Array(8).fill(null),\n            [\n                { colour: Colour.Red, position: { x: 0, y: 5 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 2, y: 5 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 4, y: 5 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 6, y: 5 }, hasPromoted: false },\n                null,\n            ],\n            [\n                null,\n                { colour: Colour.Red, position: { x: 1, y: 6 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 3, y: 6 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 5, y: 6 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 7, y: 6 }, hasPromoted: false },\n            ],\n            [\n                { colour: Colour.Red, position: { x: 0, y: 7 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 2, y: 7 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 4, y: 7 }, hasPromoted: false },\n                null,\n                { colour: Colour.Red, position: { x: 6, y: 7 }, hasPromoted: false },\n                null,\n            ],\n        ]\n    };\n    return {\n        board: board,\n        turn: Turn.RedTurn,\n        turnType: TurnType.Next,\n        gameOver: false,\n        currentPieceLocation: { x: -1, y: -1 }\n    };\n}\nfunction gameOver(gameState) {\n    var colour = gameState.turn === Turn.RedTurn ? Colour.Black : Colour.Red;\n    // check if the other player has any moves left to make or has any pieces left\n    for (var i = 0; i < 8; i++) {\n        for (var j = 0; j < 8; j++) {\n            var square = gameState.board.grid[i][j];\n            if (square !== null &&\n                square.colour === colour &&\n                getCaptureMoves(square, gameState.board).concat(getNonCaptureMoves(square, gameState.board)).length > 0)\n                return false;\n        }\n    }\n    return true;\n}\nfunction isValidPiece(pieceX, pieceY, gameState) {\n    return (isValidCoordinate({ x: pieceX, y: pieceY }) &&\n        gameState.board.grid[pieceY][pieceX] !== null &&\n        ((gameState.board.grid[pieceY][pieceX].colour === Colour.Red &&\n            gameState.turn === Turn.RedTurn) ||\n            (gameState.board.grid[pieceY][pieceX].colour === Colour.Black &&\n                gameState.turn === Turn.BlackTurn)) &&\n        getCaptureMoves(gameState.board.grid[pieceY][pieceX], gameState.board).concat(getNonCaptureMoves(gameState.board.grid[pieceY][pieceX], gameState.board)).length > 0);\n}\nfunction main() {\n    var state = newState();\n    var prompt_sync = require(\"prompt-sync\")();\n    while (!gameOver(state)) {\n        printBoard(state.board);\n        console.log(state.turn === Turn.RedTurn ? \"Red's turn\" : \"Black's Turn\");\n        // Next turn\n        if (state.turnType === TurnType.Next) {\n            var validPiece = false;\n            var inputX = -1;\n            var inputY = -1;\n            while (!validPiece) {\n                inputX = parseInt(prompt_sync(\"Enter column of piece: \"));\n                inputY = parseInt(prompt_sync(\"Enter row of piece: \"));\n                if (isValidPiece(inputX, inputY, state))\n                    validPiece = true;\n                else\n                    console.log(\"Invalid piece location. Try again\");\n            }\n            var captureMoves = getCaptureMoves(state.board.grid[inputY][inputX], state.board);\n            var nonCaptureMoves = getNonCaptureMoves(state.board.grid[inputY][inputX], state.board);\n            var allMoves = captureMoves.concat(nonCaptureMoves);\n            var validMove = false;\n            var moveIndex = -1;\n            console.log(allMoves);\n            while (!validMove) {\n                moveIndex = parseInt(prompt_sync(\"Enter index in moves array: \"));\n                if (moveIndex >= 0 && moveIndex < allMoves.length)\n                    validMove = true;\n                else\n                    console.log(\"Invalid move index. Try again.\");\n            }\n            // assume state is immutable and reassign state as needed\n            var newState_1 = makeMove({ x: inputX, y: inputY }, { x: allMoves[moveIndex].x, y: allMoves[moveIndex].y }, state);\n            state = newState_1;\n        }\n        // Next turn\n        else {\n            var captureMoves = getCaptureMoves(state.board.grid[state.currentPieceLocation.y][state.currentPieceLocation.x], state.board);\n            var validCapture = false;\n            var captureIndex = -1;\n            console.log(captureMoves);\n            while (!validCapture) {\n                captureIndex = parseInt(prompt_sync(\"Enter index in capture moves array: \"));\n                if (captureIndex >= 0 && captureIndex < captureMoves.length)\n                    validCapture = true;\n                else\n                    console.log(\"Invalid move index. Try again.\");\n            }\n            var newState_2 = makeMove({ x: state.currentPieceLocation.x, y: state.currentPieceLocation.y }, { x: captureMoves[captureIndex].x, y: captureMoves[captureIndex].y }, state);\n            state = newState_2;\n        }\n    }\n    if (state.turn === Turn.RedTurn)\n        console.log(\"Black wins! \");\n    else\n        console.log(\"Red wins! \");\n}\nmain();\n"]},"metadata":{},"sourceType":"module"}