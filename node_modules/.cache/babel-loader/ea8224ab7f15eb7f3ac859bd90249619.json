{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar stripAnsi = require('strip-ansi');\n\nvar term = 13; // carriage return\n\n/**\n * create -- sync function for reading user input from stdin\n * @param   {Object} config {\n *   sigint: {Boolean} exit on ^C\n *   autocomplete: {StringArray} function({String})\n *   history: {String} a history control object (see `prompt-sync-history`)\n * }\n * @returns {Function} prompt function\n */\n// for ANSI escape codes reference see https://en.wikipedia.org/wiki/ANSI_escape_code\n\nfunction create(config) {\n  config = config || {};\n  var sigint = config.sigint;\n  var eot = config.eot;\n\n  var autocomplete = config.autocomplete = config.autocomplete || function () {\n    return [];\n  };\n\n  var history = config.history;\n  prompt.history = history || {\n    save: function () {}\n  };\n\n  prompt.hide = function (ask) {\n    return prompt(ask, {\n      echo: ''\n    });\n  };\n\n  return prompt;\n  /**\n   * prompt -- sync function for reading user input from stdin\n   *  @param {String} ask opening question/statement to prompt for\n   *  @param {String} value initial value for the prompt\n   *  @param   {Object} opts {\n   *   echo: set to a character to be echoed, default is '*'. Use '' for no echo\n   *   value: {String} initial value for the prompt\n   *   ask: {String} opening question/statement to prompt for, does not override ask param\n   *   autocomplete: {StringArray} function({String})\n   * }\n   *\n   * @returns {string} Returns the string input or (if sigint === false)\n   *                   null if user terminates with a ^C\n   */\n\n  function prompt(ask, value, opts) {\n    var insert = 0,\n        savedinsert = 0,\n        res,\n        i,\n        savedstr;\n    opts = opts || {};\n\n    if (Object(ask) === ask) {\n      opts = ask;\n      ask = opts.ask;\n    } else if (Object(value) === value) {\n      opts = value;\n      value = opts.value;\n    }\n\n    ask = ask || '';\n    var echo = opts.echo;\n    var masked = ('echo' in opts);\n    autocomplete = opts.autocomplete || autocomplete;\n    var fd = process.platform === 'win32' ? process.stdin.fd : fs.openSync('/dev/tty', 'rs');\n    var wasRaw = process.stdin.isRaw;\n\n    if (!wasRaw) {\n      process.stdin.setRawMode && process.stdin.setRawMode(true);\n    }\n\n    var buf = Buffer.alloc(3);\n    var str = '',\n        character,\n        read;\n    savedstr = '';\n\n    if (ask) {\n      process.stdout.write(ask);\n    }\n\n    var cycle = 0;\n    var prevComplete;\n\n    while (true) {\n      read = fs.readSync(fd, buf, 0, 3);\n\n      if (read > 1) {\n        // received a control sequence\n        switch (buf.toString()) {\n          case '\\u001b[A':\n            //up arrow\n            if (masked) break;\n            if (!history) break;\n            if (history.atStart()) break;\n\n            if (history.atEnd()) {\n              savedstr = str;\n              savedinsert = insert;\n            }\n\n            str = history.prev();\n            insert = str.length;\n            process.stdout.write('\\u001b[2K\\u001b[0G' + ask + str);\n            break;\n\n          case '\\u001b[B':\n            //down arrow\n            if (masked) break;\n            if (!history) break;\n            if (history.pastEnd()) break;\n\n            if (history.atPenultimate()) {\n              str = savedstr;\n              insert = savedinsert;\n              history.next();\n            } else {\n              str = history.next();\n              insert = str.length;\n            }\n\n            process.stdout.write('\\u001b[2K\\u001b[0G' + ask + str + '\\u001b[' + (insert + ask.length + 1) + 'G');\n            break;\n\n          case '\\u001b[D':\n            //left arrow\n            if (masked) break;\n            var before = insert;\n            insert = --insert < 0 ? 0 : insert;\n            if (before - insert) process.stdout.write('\\u001b[1D');\n            break;\n\n          case '\\u001b[C':\n            //right arrow\n            if (masked) break;\n            insert = ++insert > str.length ? str.length : insert;\n            process.stdout.write('\\u001b[' + (insert + ask.length + 1) + 'G');\n            break;\n\n          default:\n            if (buf.toString()) {\n              str = str + buf.toString();\n              str = str.replace(/\\0/g, '');\n              insert = str.length;\n              promptPrint(masked, ask, echo, str, insert);\n              process.stdout.write('\\u001b[' + (insert + ask.length + 1) + 'G');\n              buf = Buffer.alloc(3);\n            }\n\n        }\n\n        continue; // any other 3 character sequence is ignored\n      } // if it is not a control character seq, assume only one character is read\n\n\n      character = buf[read - 1]; // catch a ^C and return null\n\n      if (character == 3) {\n        process.stdout.write('^C\\n');\n        fs.closeSync(fd);\n        if (sigint) process.exit(130);\n        process.stdin.setRawMode && process.stdin.setRawMode(wasRaw);\n        return null;\n      } // catch a ^D and exit\n\n\n      if (character == 4) {\n        if (str.length == 0 && eot) {\n          process.stdout.write('exit\\n');\n          process.exit(0);\n        }\n      } // catch the terminating character\n\n\n      if (character == term) {\n        fs.closeSync(fd);\n        if (!history) break;\n        if (!masked && str.length) history.push(str);\n        history.reset();\n        break;\n      } // catch a TAB and implement autocomplete\n\n\n      if (character == 9) {\n        // TAB\n        res = autocomplete(str);\n\n        if (str == res[0]) {\n          res = autocomplete('');\n        } else {\n          prevComplete = res.length;\n        }\n\n        if (res.length == 0) {\n          process.stdout.write('\\t');\n          continue;\n        }\n\n        var item = res[cycle++] || res[(cycle = 0, cycle++)];\n\n        if (item) {\n          process.stdout.write('\\r\\u001b[K' + ask + item);\n          str = item;\n          insert = item.length;\n        }\n      }\n\n      if (character == 127 || process.platform == 'win32' && character == 8) {\n        //backspace\n        if (!insert) continue;\n        str = str.slice(0, insert - 1) + str.slice(insert);\n        insert--;\n        process.stdout.write('\\u001b[2D');\n      } else {\n        if (character < 32 || character > 126) continue;\n        str = str.slice(0, insert) + String.fromCharCode(character) + str.slice(insert);\n        insert++;\n      }\n\n      ;\n      promptPrint(masked, ask, echo, str, insert);\n    }\n\n    process.stdout.write('\\n');\n    process.stdin.setRawMode && process.stdin.setRawMode(wasRaw);\n    return str || value || '';\n  }\n\n  ;\n\n  function promptPrint(masked, ask, echo, str, insert) {\n    if (masked) {\n      process.stdout.write('\\u001b[2K\\u001b[0G' + ask + Array(str.length + 1).join(echo));\n    } else {\n      process.stdout.write('\\u001b[s');\n\n      if (insert == str.length) {\n        process.stdout.write('\\u001b[2K\\u001b[0G' + ask + str);\n      } else {\n        if (ask) {\n          process.stdout.write('\\u001b[2K\\u001b[0G' + ask + str);\n        } else {\n          process.stdout.write('\\u001b[2K\\u001b[0G' + str + '\\u001b[' + (str.length - insert) + 'D');\n        }\n      } // Reposition the cursor to the right of the insertion point\n\n\n      var askLength = stripAnsi(ask).length;\n      process.stdout.write(`\\u001b[${askLength + 1 + (echo == '' ? 0 : insert)}G`);\n    }\n  }\n}\n\n;\nmodule.exports = create;","map":{"version":3,"sources":["/Users/janujansritharan/Projects/Checkers-React/node_modules/prompt-sync/index.js"],"names":["fs","require","stripAnsi","term","create","config","sigint","eot","autocomplete","history","prompt","save","hide","ask","echo","value","opts","insert","savedinsert","res","i","savedstr","Object","masked","fd","process","platform","stdin","openSync","wasRaw","isRaw","setRawMode","buf","Buffer","alloc","str","character","read","stdout","write","cycle","prevComplete","readSync","toString","atStart","atEnd","prev","length","pastEnd","atPenultimate","next","before","replace","promptPrint","closeSync","exit","push","reset","item","slice","String","fromCharCode","Array","join","askLength","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar fs = require('fs');\nvar stripAnsi = require('strip-ansi');\nvar term = 13; // carriage return\n\n/**\n * create -- sync function for reading user input from stdin\n * @param   {Object} config {\n *   sigint: {Boolean} exit on ^C\n *   autocomplete: {StringArray} function({String})\n *   history: {String} a history control object (see `prompt-sync-history`)\n * }\n * @returns {Function} prompt function\n */\n\n // for ANSI escape codes reference see https://en.wikipedia.org/wiki/ANSI_escape_code\n\nfunction create(config) {\n\n  config = config || {};\n  var sigint = config.sigint;\n  var eot = config.eot;\n  var autocomplete = config.autocomplete =\n    config.autocomplete || function(){return []};\n  var history = config.history;\n  prompt.history = history || {save: function(){}};\n  prompt.hide = function (ask) { return prompt(ask, {echo: ''}) };\n\n  return prompt;\n\n\n  /**\n   * prompt -- sync function for reading user input from stdin\n   *  @param {String} ask opening question/statement to prompt for\n   *  @param {String} value initial value for the prompt\n   *  @param   {Object} opts {\n   *   echo: set to a character to be echoed, default is '*'. Use '' for no echo\n   *   value: {String} initial value for the prompt\n   *   ask: {String} opening question/statement to prompt for, does not override ask param\n   *   autocomplete: {StringArray} function({String})\n   * }\n   *\n   * @returns {string} Returns the string input or (if sigint === false)\n   *                   null if user terminates with a ^C\n   */\n\n\n  function prompt(ask, value, opts) {\n    var insert = 0, savedinsert = 0, res, i, savedstr;\n    opts = opts || {};\n\n    if (Object(ask) === ask) {\n      opts = ask;\n      ask = opts.ask;\n    } else if (Object(value) === value) {\n      opts = value;\n      value = opts.value;\n    }\n    ask = ask || '';\n    var echo = opts.echo;\n    var masked = 'echo' in opts;\n    autocomplete = opts.autocomplete || autocomplete;\n\n    var fd = (process.platform === 'win32') ?\n      process.stdin.fd :\n      fs.openSync('/dev/tty', 'rs');\n\n    var wasRaw = process.stdin.isRaw;\n    if (!wasRaw) { process.stdin.setRawMode && process.stdin.setRawMode(true); }\n\n    var buf = Buffer.alloc(3);\n    var str = '', character, read;\n\n    savedstr = '';\n\n    if (ask) {\n      process.stdout.write(ask);\n    }\n\n    var cycle = 0;\n    var prevComplete;\n\n    while (true) {\n      read = fs.readSync(fd, buf, 0, 3);\n      if (read > 1) { // received a control sequence\n        switch(buf.toString()) {\n          case '\\u001b[A':  //up arrow\n            if (masked) break;\n            if (!history) break;\n            if (history.atStart()) break;\n\n            if (history.atEnd()) {\n              savedstr = str;\n              savedinsert = insert;\n            }\n            str = history.prev();\n            insert = str.length;\n            process.stdout.write('\\u001b[2K\\u001b[0G' + ask + str);\n            break;\n          case '\\u001b[B':  //down arrow\n            if (masked) break;\n            if (!history) break;\n            if (history.pastEnd()) break;\n\n            if (history.atPenultimate()) {\n              str = savedstr;\n              insert = savedinsert;\n              history.next();\n            } else {\n              str = history.next();\n              insert = str.length;\n            }\n            process.stdout.write('\\u001b[2K\\u001b[0G'+ ask + str + '\\u001b['+(insert+ask.length+1)+'G');\n            break;\n          case '\\u001b[D': //left arrow\n            if (masked) break;\n            var before = insert;\n            insert = (--insert < 0) ? 0 : insert;\n            if (before - insert)\n              process.stdout.write('\\u001b[1D');\n            break;\n          case '\\u001b[C': //right arrow\n            if (masked) break;\n            insert = (++insert > str.length) ? str.length : insert;\n            process.stdout.write('\\u001b[' + (insert+ask.length+1) + 'G');\n            break;\n          default:\n            if (buf.toString()) {\n              str = str + buf.toString();\n              str = str.replace(/\\0/g, '');\n              insert = str.length;\n              promptPrint(masked, ask, echo, str, insert);\n              process.stdout.write('\\u001b[' + (insert+ask.length+1) + 'G');\n              buf = Buffer.alloc(3);\n            }\n        }\n        continue; // any other 3 character sequence is ignored\n      }\n\n      // if it is not a control character seq, assume only one character is read\n      character = buf[read-1];\n\n      // catch a ^C and return null\n      if (character == 3){\n        process.stdout.write('^C\\n');\n        fs.closeSync(fd);\n\n        if (sigint) process.exit(130);\n\n        process.stdin.setRawMode && process.stdin.setRawMode(wasRaw);\n\n        return null;\n      }\n\n      // catch a ^D and exit\n      if (character == 4) {\n        if (str.length == 0 && eot) {\n          process.stdout.write('exit\\n');\n          process.exit(0);\n        }\n      }\n\n      // catch the terminating character\n      if (character == term) {\n        fs.closeSync(fd);\n        if (!history) break;\n        if (!masked && str.length) history.push(str);\n        history.reset();\n        break;\n      }\n\n      // catch a TAB and implement autocomplete\n      if (character == 9) { // TAB\n        res = autocomplete(str);\n\n        if (str == res[0]) {\n          res = autocomplete('');\n        } else {\n          prevComplete = res.length;\n        }\n\n        if (res.length == 0) {\n          process.stdout.write('\\t');\n          continue;\n        }\n\n        var item = res[cycle++] || res[cycle = 0, cycle++];\n\n        if (item) {\n          process.stdout.write('\\r\\u001b[K' + ask + item);\n          str = item;\n          insert = item.length;\n        }\n      }\n\n      if (character == 127 || (process.platform == 'win32' && character == 8)) { //backspace\n        if (!insert) continue;\n        str = str.slice(0, insert-1) + str.slice(insert);\n        insert--;\n        process.stdout.write('\\u001b[2D');\n      } else {\n        if ((character < 32 ) || (character > 126))\n            continue;\n        str = str.slice(0, insert) + String.fromCharCode(character) + str.slice(insert);\n        insert++;\n      };\n\n      promptPrint(masked, ask, echo, str, insert);\n\n    }\n\n    process.stdout.write('\\n')\n\n    process.stdin.setRawMode && process.stdin.setRawMode(wasRaw);\n\n    return str || value || '';\n  };\n\n\n  function promptPrint(masked, ask, echo, str, insert) {\n    if (masked) {\n        process.stdout.write('\\u001b[2K\\u001b[0G' + ask + Array(str.length+1).join(echo));\n    } else {\n      process.stdout.write('\\u001b[s');\n      if (insert == str.length) {\n          process.stdout.write('\\u001b[2K\\u001b[0G'+ ask + str);\n      } else {\n        if (ask) {\n          process.stdout.write('\\u001b[2K\\u001b[0G'+ ask + str);\n        } else {\n          process.stdout.write('\\u001b[2K\\u001b[0G'+ str + '\\u001b[' + (str.length - insert) + 'D');\n        }\n      }\n\n      // Reposition the cursor to the right of the insertion point\n      var askLength = stripAnsi(ask).length;\n      process.stdout.write(`\\u001b[${askLength+1+(echo==''? 0:insert)}G`);\n    }\n  }\n};\n\nmodule.exports = create;\n"]},"metadata":{},"sourceType":"script"}