{"ast":null,"code":"export let Turn;\n\n(function (Turn) {\n  Turn[Turn[\"RedTurn\"] = 1] = \"RedTurn\";\n  Turn[Turn[\"BlackTurn\"] = 2] = \"BlackTurn\";\n})(Turn || (Turn = {}));\n\nexport let TurnType;\n\n(function (TurnType) {\n  TurnType[TurnType[\"Continue\"] = 1] = \"Continue\";\n  TurnType[TurnType[\"Next\"] = 2] = \"Next\";\n})(TurnType || (TurnType = {}));\n\nexport let Colour;\n\n(function (Colour) {\n  Colour[Colour[\"Red\"] = 1] = \"Red\";\n  Colour[Colour[\"Black\"] = 2] = \"Black\";\n})(Colour || (Colour = {}));\n\nexport function isValidCoordinate(position) {\n  return position.x < 8 && position.x >= 0 && position.y < 8 && position.y >= 0;\n}\nexport function getNonCaptureMoves(piece, board) {\n  let moves;\n  let directionFactor = piece.colour === Colour.Red ? -1 : 1; //get possible move locations\n\n  if (piece.hasPromoted) moves = [{\n    x: piece.position.x + 1,\n    y: piece.position.y + 1\n  }, {\n    x: piece.position.x - 1,\n    y: piece.position.y + 1\n  }, {\n    x: piece.position.x + 1,\n    y: piece.position.y - 1\n  }, {\n    x: piece.position.x - 1,\n    y: piece.position.y - 1\n  }];else moves = [{\n    x: piece.position.x + 1,\n    y: piece.position.y + directionFactor\n  }, {\n    x: piece.position.x - 1,\n    y: piece.position.y + directionFactor\n  }];\n  let filteredMoves = [];\n\n  for (let i = 0; i < moves.length; i++) {\n    if (isValidCoordinate(moves[i]) && board.grid[moves[i].y][moves[i].x] === null) filteredMoves.push(moves[i]);\n  }\n\n  return filteredMoves;\n}\nexport function getCaptureMoves(piece, board) {\n  let moves;\n  let directionFactor = piece.colour === Colour.Red ? -1 : 1;\n  if (piece.hasPromoted) moves = [{\n    x: piece.position.x + 2,\n    y: piece.position.y + 2\n  }, {\n    x: piece.position.x - 2,\n    y: piece.position.y + 2\n  }, {\n    x: piece.position.x + 2,\n    y: piece.position.y - 2\n  }, {\n    x: piece.position.x - 2,\n    y: piece.position.y - 2\n  }];else moves = [{\n    x: piece.position.x + 2,\n    y: piece.position.y + 2 * directionFactor\n  }, {\n    x: piece.position.x - 2,\n    y: piece.position.y + 2 * directionFactor\n  }];\n  let filteredMoves = [];\n\n  for (let i = 0; i < moves.length; i++) {\n    if (isValidCoordinate(moves[i]) && board.grid[moves[i].y][moves[i].x] === null && board.grid[(moves[i].y + piece.position.y) / 2][(moves[i].x + piece.position.x) / 2] !== null && board.grid[(moves[i].y + piece.position.y) / 2][(moves[i].x + piece.position.x) / 2].colour !== piece.colour) filteredMoves.push(moves[i]);\n  }\n\n  return filteredMoves;\n}\nexport function makeMove(initial, final, prevState) {\n  let tempGrid = []; //create deep copy of the board\n\n  for (let i = 0; i < 8; i++) {\n    let temp = [];\n\n    for (let j = 0; j < 8; j++) {\n      if (prevState.board.grid[i][j] === null) temp.push(null);else {\n        let piece = prevState.board.grid[i][j];\n        let checker = {\n          colour: piece.colour,\n          position: {\n            x: piece.position.x,\n            y: piece.position.y\n          },\n          hasPromoted: piece.hasPromoted\n        };\n        temp.push(checker);\n      }\n    }\n\n    tempGrid.push(temp);\n  }\n\n  let movingChecker = tempGrid[initial.y][initial.x];\n  if (movingChecker === null) return prevState;\n  let newChecker = {\n    colour: movingChecker.colour,\n    position: final,\n    hasPromoted: movingChecker.hasPromoted\n  }; //promote if back rank has been reached\n\n  if (movingChecker.colour === Colour.Red && final.y === 0 || movingChecker.colour === Colour.Black && final.y === 7) newChecker.hasPromoted = true;\n  tempGrid[initial.y][initial.x] = null;\n  tempGrid[final.y][final.x] = newChecker;\n  let captureMade = false;\n\n  if (Math.abs(initial.x - final.x) == 2) {\n    captureMade = true;\n    tempGrid[(initial.y + final.y) / 2][(initial.x + final.x) / 2] = null;\n  }\n\n  let nextTurnType = captureMade && getCaptureMoves(tempGrid[final.y][final.x], {\n    grid: tempGrid\n  }).length > 0 ? TurnType.Continue : TurnType.Next;\n  let otherTurn = prevState.turn === Turn.RedTurn ? Turn.BlackTurn : Turn.RedTurn;\n  let nextTurn = nextTurnType === TurnType.Continue ? prevState.turn : otherTurn;\n  return {\n    board: {\n      grid: tempGrid\n    },\n    turn: nextTurn,\n    turnType: nextTurnType,\n    gameOver: prevState.gameOver,\n    currentPieceLocation: final\n  };\n}\n\nfunction printBoard(board) {\n  for (let i = 0; i < 8; i++) {\n    let st = \"\";\n\n    for (let j = 0; j < 8; j++) {\n      let ch;\n      if (board.grid[i][j] == null) st += \" -\";else {\n        var _board$grid$i$j;\n\n        let ch = board.grid[i][j].colour === Colour.Red ? \"r\" : \"b\";\n        if ((_board$grid$i$j = board.grid[i][j]) !== null && _board$grid$i$j !== void 0 && _board$grid$i$j.hasPromoted) ch = ch.toUpperCase();\n        st = st + \" \" + ch;\n      }\n    }\n\n    console.log(st);\n  }\n}\n\nexport function newState() {\n  let board = {\n    grid: [[null, {\n      colour: Colour.Black,\n      position: {\n        x: 1,\n        y: 0\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 3,\n        y: 0\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 5,\n        y: 0\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 7,\n        y: 0\n      },\n      hasPromoted: false\n    }], [{\n      colour: Colour.Black,\n      position: {\n        x: 0,\n        y: 1\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 2,\n        y: 1\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 4,\n        y: 1\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 6,\n        y: 1\n      },\n      hasPromoted: false\n    }, null], [null, {\n      colour: Colour.Black,\n      position: {\n        x: 1,\n        y: 2\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 3,\n        y: 2\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 5,\n        y: 2\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Black,\n      position: {\n        x: 7,\n        y: 2\n      },\n      hasPromoted: false\n    }], Array(8).fill(null), Array(8).fill(null), [{\n      colour: Colour.Red,\n      position: {\n        x: 0,\n        y: 5\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 2,\n        y: 5\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 4,\n        y: 5\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 6,\n        y: 5\n      },\n      hasPromoted: false\n    }, null], [null, {\n      colour: Colour.Red,\n      position: {\n        x: 1,\n        y: 6\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 3,\n        y: 6\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 5,\n        y: 6\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 7,\n        y: 6\n      },\n      hasPromoted: false\n    }], [{\n      colour: Colour.Red,\n      position: {\n        x: 0,\n        y: 7\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 2,\n        y: 7\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 4,\n        y: 7\n      },\n      hasPromoted: false\n    }, null, {\n      colour: Colour.Red,\n      position: {\n        x: 6,\n        y: 7\n      },\n      hasPromoted: false\n    }, null]]\n  };\n  return {\n    board: board,\n    turn: Turn.RedTurn,\n    turnType: TurnType.Next,\n    gameOver: false,\n    currentPieceLocation: {\n      x: -1,\n      y: -1\n    }\n  };\n}\nexport function gameOver(gameState) {\n  let colour = gameState.turn === Turn.RedTurn ? Colour.Black : Colour.Red; // check if the other player has any moves left to make or has any pieces left\n\n  for (let i = 0; i < 8; i++) {\n    for (let j = 0; j < 8; j++) {\n      let square = gameState.board.grid[i][j];\n      if (square !== null && square.colour === colour && getCaptureMoves(square, gameState.board).concat(getNonCaptureMoves(square, gameState.board)).length > 0) return false;\n    }\n  }\n\n  return true;\n}\nexport function isValidPiece(pieceX, pieceY, gameState) {\n  return isValidCoordinate({\n    x: pieceX,\n    y: pieceY\n  }) && gameState.board.grid[pieceY][pieceX] !== null && (gameState.board.grid[pieceY][pieceX].colour === Colour.Red && gameState.turn === Turn.RedTurn || gameState.board.grid[pieceY][pieceX].colour === Colour.Black && gameState.turn === Turn.BlackTurn) && getCaptureMoves(gameState.board.grid[pieceY][pieceX], gameState.board).concat(getNonCaptureMoves(gameState.board.grid[pieceY][pieceX], gameState.board)).length > 0;\n}\n/*function main() {\n  let state: CheckersState = newState();\n  var prompt_sync = require(\"prompt-sync\")();\n\n  while (!gameOver(state)) {\n    printBoard(state.board);\n    console.log(state.turn === Turn.RedTurn ? \"Red's turn\" : \"Black's Turn\");\n\n    // Next turn\n    if (state.turnType === TurnType.Next) {\n      let validPiece: boolean = false;\n      let inputX: number = -1;\n      let inputY: number = -1;\n\n      while (!validPiece) {\n        inputX = parseInt(prompt_sync(\"Enter column of piece: \"));\n        inputY = parseInt(prompt_sync(\"Enter row of piece: \"));\n        if (isValidPiece(inputX, inputY, state)) validPiece = true;\n        else console.log(\"Invalid piece location. Try again\");\n      }\n\n      let captureMoves: Position[] = getCaptureMoves(\n        state.board.grid[inputY][inputX]!,\n        state.board\n      );\n      let nonCaptureMoves: Position[] = getNonCaptureMoves(\n        state.board.grid[inputY][inputX]!,\n        state.board\n      );\n      let allMoves: Position[] = captureMoves.concat(nonCaptureMoves);\n      let validMove: boolean = false;\n      let moveIndex: number = -1;\n\n      console.log(allMoves);\n\n      while (!validMove) {\n        moveIndex = parseInt(prompt_sync(\"Enter index in moves array: \")!);\n        if (moveIndex >= 0 && moveIndex < allMoves.length) validMove = true;\n        else console.log(\"Invalid move index. Try again.\");\n      }\n\n      // assume state is immutable and reassign state as needed\n      let newState: CheckersState = makeMove(\n        { x: inputX, y: inputY },\n        { x: allMoves[moveIndex].x, y: allMoves[moveIndex].y },\n        state\n      );\n\n      state = newState;\n    }\n    // Next turn\n    else {\n      let captureMoves: Position[] = getCaptureMoves(\n        state.board.grid[state.currentPieceLocation.y][\n          state.currentPieceLocation.x\n        ]!,\n        state.board\n      );\n      let validCapture: boolean = false;\n      let captureIndex: number = -1;\n\n      console.log(captureMoves);\n      while (!validCapture) {\n        captureIndex = parseInt(\n          prompt_sync(\"Enter index in capture moves array: \")\n        );\n        if (captureIndex >= 0 && captureIndex < captureMoves.length)\n          validCapture = true;\n        else console.log(\"Invalid move index. Try again.\");\n      }\n      let newState: CheckersState = makeMove(\n        { x: state.currentPieceLocation.x, y: state.currentPieceLocation.y },\n        { x: captureMoves[captureIndex].x, y: captureMoves[captureIndex].y },\n        state\n      );\n      state = newState;\n    }\n  }\n\n  if (state.turn === Turn.RedTurn) console.log(\"Black wins! \");\n  else console.log(\"Red wins! \");\n}\n\nmain();\n*/","map":{"version":3,"sources":["/Users/janujansritharan/Projects/Checkers-React/src/checkersState.ts"],"names":["Turn","TurnType","Colour","isValidCoordinate","position","x","y","getNonCaptureMoves","piece","board","moves","directionFactor","colour","Red","hasPromoted","filteredMoves","i","length","grid","push","getCaptureMoves","makeMove","initial","final","prevState","tempGrid","temp","j","checker","movingChecker","newChecker","Black","captureMade","Math","abs","nextTurnType","Continue","Next","otherTurn","turn","RedTurn","BlackTurn","nextTurn","turnType","gameOver","currentPieceLocation","printBoard","st","ch","toUpperCase","console","log","newState","Array","fill","gameState","square","concat","isValidPiece","pieceX","pieceY"],"mappings":"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","sourcesContent":["export interface CheckersState {\n  board: Board;\n  turn: Turn;\n  turnType: TurnType;\n  gameOver: boolean;\n  currentPieceLocation: Position;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport enum Turn {\n  RedTurn = 1,\n  BlackTurn = 2,\n}\n\nexport enum TurnType {\n  Continue = 1,\n  Next = 2,\n}\n\nexport enum Colour {\n  Red = 1,\n  Black = 2,\n}\n\nexport interface Checker {\n  colour: Colour;\n  position: Position;\n  hasPromoted: boolean;\n}\n\nexport interface Board {\n  grid: (Checker | null)[][];\n}\n\nexport function isValidCoordinate(position: Position): boolean {\n  return position.x < 8 && position.x >= 0 && position.y < 8 && position.y >= 0;\n}\n\nexport function getNonCaptureMoves(piece: Checker, board: Board): Position[] {\n  let moves: Position[];\n  let directionFactor: number = piece.colour === Colour.Red ? -1 : 1;\n\n  //get possible move locations\n  if (piece.hasPromoted)\n    moves = [\n      { x: piece.position.x + 1, y: piece.position.y + 1 },\n      { x: piece.position.x - 1, y: piece.position.y + 1 },\n      { x: piece.position.x + 1, y: piece.position.y - 1 },\n      { x: piece.position.x - 1, y: piece.position.y - 1 },\n    ];\n  else\n    moves = [\n      { x: piece.position.x + 1, y: piece.position.y + directionFactor },\n      { x: piece.position.x - 1, y: piece.position.y + directionFactor },\n    ];\n\n  let filteredMoves: Position[] = [];\n\n  for (let i = 0; i < moves.length; i++) {\n    if (\n      isValidCoordinate(moves[i]) &&\n      board.grid[moves[i].y][moves[i].x] === null\n    )\n      filteredMoves.push(moves[i]);\n  }\n\n  return filteredMoves;\n}\n\nexport function getCaptureMoves(piece: Checker, board: Board): Position[] {\n  let moves: Position[];\n  let directionFactor: number = piece.colour === Colour.Red ? -1 : 1;\n\n  if (piece.hasPromoted)\n    moves = [\n      { x: piece.position.x + 2, y: piece.position.y + 2 },\n      { x: piece.position.x - 2, y: piece.position.y + 2 },\n      { x: piece.position.x + 2, y: piece.position.y - 2 },\n      { x: piece.position.x - 2, y: piece.position.y - 2 },\n    ];\n  else\n    moves = [\n      { x: piece.position.x + 2, y: piece.position.y + 2 * directionFactor },\n      { x: piece.position.x - 2, y: piece.position.y + 2 * directionFactor },\n    ];\n\n  let filteredMoves: Position[] = [];\n\n  for (let i = 0; i < moves.length; i++) {\n    if (\n      isValidCoordinate(moves[i]) &&\n      board.grid[moves[i].y][moves[i].x] === null &&\n      board.grid[(moves[i].y + piece.position.y) / 2][\n        (moves[i].x + piece.position.x) / 2\n      ] !== null &&\n      board.grid[(moves[i].y + piece.position.y) / 2][\n        (moves[i].x + piece.position.x) / 2\n      ]!.colour !== piece.colour\n    )\n      filteredMoves.push(moves[i]);\n  }\n\n  return filteredMoves;\n}\n\nexport function makeMove(\n  initial: Position,\n  final: Position,\n  prevState: CheckersState\n): CheckersState {\n  let tempGrid: (Checker | null)[][] = [];\n\n  //create deep copy of the board\n  for (let i = 0; i < 8; i++) {\n    let temp: (Checker | null)[] = [];\n    for (let j = 0; j < 8; j++) {\n      if (prevState.board.grid[i][j] === null) temp.push(null);\n      else {\n        let piece = prevState.board.grid[i][j];\n        let checker: Checker = {\n          colour: piece!.colour,\n          position: { x: piece!.position.x, y: piece!.position.y },\n          hasPromoted: piece!.hasPromoted,\n        };\n        temp.push(checker);\n      }\n    }\n    tempGrid.push(temp);\n  }\n\n  let movingChecker: Checker | null = tempGrid[initial.y][initial.x];\n\n  if (movingChecker === null) return prevState;\n  let newChecker: Checker = {\n    colour: movingChecker.colour,\n    position: final,\n    hasPromoted: movingChecker.hasPromoted,\n  };\n\n  //promote if back rank has been reached\n  if (\n    (movingChecker.colour === Colour.Red && final.y === 0) ||\n    (movingChecker.colour === Colour.Black && final.y === 7)\n  )\n    newChecker.hasPromoted = true;\n\n  tempGrid[initial.y][initial.x] = null;\n  tempGrid[final.y][final.x] = newChecker;\n  let captureMade: boolean = false;\n\n  if (Math.abs(initial.x - final.x) == 2) {\n    captureMade = true;\n    tempGrid[(initial.y + final.y) / 2][(initial.x + final.x) / 2] = null;\n  }\n\n  let nextTurnType: TurnType =\n    captureMade &&\n    getCaptureMoves(tempGrid[final.y][final.x]!, { grid: tempGrid }).length > 0\n      ? TurnType.Continue\n      : TurnType.Next;\n  let otherTurn: Turn =\n    prevState.turn === Turn.RedTurn ? Turn.BlackTurn : Turn.RedTurn;\n  let nextTurn: Turn =\n    nextTurnType === TurnType.Continue ? prevState.turn : otherTurn;\n\n  return {\n    board: { grid: tempGrid },\n    turn: nextTurn,\n    turnType: nextTurnType,\n    gameOver: prevState.gameOver,\n    currentPieceLocation: final,\n  };\n}\n\nfunction printBoard(board: Board) {\n  for (let i = 0; i < 8; i++) {\n    let st: string = \"\";\n\n    for (let j = 0; j < 8; j++) {\n      let ch: string;\n      if (board.grid[i][j] == null) st += \" -\";\n      else {\n        let ch: string = board.grid[i][j]!.colour === Colour.Red ? \"r\" : \"b\";\n        if (board.grid[i][j]?.hasPromoted) ch = ch.toUpperCase();\n        st = st + \" \" + ch;\n      }\n    }\n    console.log(st);\n  }\n}\n\nexport function newState(): CheckersState {\n  let board: Board = {\n    grid: [\n      [\n        null,\n        { colour: Colour.Black, position: { x: 1, y: 0 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 3, y: 0 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 5, y: 0 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 7, y: 0 }, hasPromoted: false },\n      ],\n      [\n        { colour: Colour.Black, position: { x: 0, y: 1 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 2, y: 1 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 4, y: 1 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 6, y: 1 }, hasPromoted: false },\n        null,\n      ],\n      [\n        null,\n        { colour: Colour.Black, position: { x: 1, y: 2 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 3, y: 2 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 5, y: 2 }, hasPromoted: false },\n        null,\n        { colour: Colour.Black, position: { x: 7, y: 2 }, hasPromoted: false },\n      ],\n      Array(8).fill(null),\n      Array(8).fill(null),\n      [\n        { colour: Colour.Red, position: { x: 0, y: 5 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 2, y: 5 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 4, y: 5 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 6, y: 5 }, hasPromoted: false },\n        null,\n      ],\n      [\n        null,\n        { colour: Colour.Red, position: { x: 1, y: 6 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 3, y: 6 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 5, y: 6 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 7, y: 6 }, hasPromoted: false },\n      ],\n      [\n        { colour: Colour.Red, position: { x: 0, y: 7 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 2, y: 7 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 4, y: 7 }, hasPromoted: false },\n        null,\n        { colour: Colour.Red, position: { x: 6, y: 7 }, hasPromoted: false },\n        null,\n      ],\n    ],\n  };\n  return {\n    board: board,\n    turn: Turn.RedTurn,\n    turnType: TurnType.Next,\n    gameOver: false,\n    currentPieceLocation: { x: -1, y: -1 },\n  };\n}\n\nexport function gameOver(gameState: CheckersState): boolean {\n  let colour: Colour =\n    gameState.turn === Turn.RedTurn ? Colour.Black : Colour.Red;\n  // check if the other player has any moves left to make or has any pieces left\n  for (let i = 0; i < 8; i++) {\n    for (let j = 0; j < 8; j++) {\n      let square: Checker | null = gameState.board.grid[i][j];\n      if (\n        square !== null &&\n        square!.colour === colour &&\n        getCaptureMoves(square!, gameState.board).concat(\n          getNonCaptureMoves(square!, gameState.board)\n        ).length > 0\n      )\n        return false;\n    }\n  }\n  return true;\n}\n\nexport function isValidPiece(\n  pieceX: number,\n  pieceY: number,\n  gameState: CheckersState\n): boolean {\n  return (\n    isValidCoordinate({ x: pieceX, y: pieceY }) &&\n    gameState.board.grid[pieceY][pieceX] !== null &&\n    ((gameState.board.grid[pieceY][pieceX]!.colour === Colour.Red &&\n      gameState.turn === Turn.RedTurn) ||\n      (gameState.board.grid[pieceY][pieceX]!.colour === Colour.Black &&\n        gameState.turn === Turn.BlackTurn)) &&\n    getCaptureMoves(\n      gameState.board.grid[pieceY][pieceX]!,\n      gameState.board\n    ).concat(\n      getNonCaptureMoves(gameState.board.grid[pieceY][pieceX]!, gameState.board)\n    ).length > 0\n  );\n}\n\n/*function main() {\n  let state: CheckersState = newState();\n  var prompt_sync = require(\"prompt-sync\")();\n\n  while (!gameOver(state)) {\n    printBoard(state.board);\n    console.log(state.turn === Turn.RedTurn ? \"Red's turn\" : \"Black's Turn\");\n\n    // Next turn\n    if (state.turnType === TurnType.Next) {\n      let validPiece: boolean = false;\n      let inputX: number = -1;\n      let inputY: number = -1;\n\n      while (!validPiece) {\n        inputX = parseInt(prompt_sync(\"Enter column of piece: \"));\n        inputY = parseInt(prompt_sync(\"Enter row of piece: \"));\n        if (isValidPiece(inputX, inputY, state)) validPiece = true;\n        else console.log(\"Invalid piece location. Try again\");\n      }\n\n      let captureMoves: Position[] = getCaptureMoves(\n        state.board.grid[inputY][inputX]!,\n        state.board\n      );\n      let nonCaptureMoves: Position[] = getNonCaptureMoves(\n        state.board.grid[inputY][inputX]!,\n        state.board\n      );\n      let allMoves: Position[] = captureMoves.concat(nonCaptureMoves);\n      let validMove: boolean = false;\n      let moveIndex: number = -1;\n\n      console.log(allMoves);\n\n      while (!validMove) {\n        moveIndex = parseInt(prompt_sync(\"Enter index in moves array: \")!);\n        if (moveIndex >= 0 && moveIndex < allMoves.length) validMove = true;\n        else console.log(\"Invalid move index. Try again.\");\n      }\n\n      // assume state is immutable and reassign state as needed\n      let newState: CheckersState = makeMove(\n        { x: inputX, y: inputY },\n        { x: allMoves[moveIndex].x, y: allMoves[moveIndex].y },\n        state\n      );\n\n      state = newState;\n    }\n    // Next turn\n    else {\n      let captureMoves: Position[] = getCaptureMoves(\n        state.board.grid[state.currentPieceLocation.y][\n          state.currentPieceLocation.x\n        ]!,\n        state.board\n      );\n      let validCapture: boolean = false;\n      let captureIndex: number = -1;\n\n      console.log(captureMoves);\n      while (!validCapture) {\n        captureIndex = parseInt(\n          prompt_sync(\"Enter index in capture moves array: \")\n        );\n        if (captureIndex >= 0 && captureIndex < captureMoves.length)\n          validCapture = true;\n        else console.log(\"Invalid move index. Try again.\");\n      }\n      let newState: CheckersState = makeMove(\n        { x: state.currentPieceLocation.x, y: state.currentPieceLocation.y },\n        { x: captureMoves[captureIndex].x, y: captureMoves[captureIndex].y },\n        state\n      );\n      state = newState;\n    }\n  }\n\n  if (state.turn === Turn.RedTurn) console.log(\"Black wins! \");\n  else console.log(\"Red wins! \");\n}\n\nmain();\n*/\n"]},"metadata":{},"sourceType":"module"}